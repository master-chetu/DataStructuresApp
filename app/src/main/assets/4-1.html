<body style="background-color:#303030;"> 
<style>
	li{
	color:#C4DFE6;font-family:tamoha;font-size:110%
	}
	h3{
	color:#65A5AD
	}
	p{
	color:#C4DFE6;font-family:tamoha;font-size:110%
	}
	pre{
	color:#C4DFE6;font-family:tamoha;font-size:110%
	}
</style>

<h3>4.1 Priority Queues - Heaps</h3>
<h3>4.1.1 Need for Priority in Queues</h3>
<li>Job Submitted to a printer</li>
<ul>
<li>Currently follows first in first out</li>
<li>Performance can be improved by allowing important documents to get printed first</li>
<li>Compared to 100-page document, one page document can be printed first so that overall waiting time can be reduced</li>
</ul>
<li>Multi user environment in an operating system</li>
<ul><li>Preference can be given to short jobs, important jobs</li></ul>

<h3>4.1.2 Priority Queues - Definition</h3>
<p>A priority queue is a data structure that supports two basic operations: <p>
<li>insert a new item - Enqueue</li>
<li>remove the minimum item - DeleteMin</li>
<ul>
<li>smaller value has higher priority</li>
<li>Finds the minimum element and deletes it from structure and returns it</li>
</ul>
<img src="hs1.png" style="width:300px;height:80px;margin-left:30px">

<h3>4.1.3 Priority Queues - Implementations</h3>
<p>A simple linked list:</p>
<ul><li>Insertion at the front (O(1)); delete minimum (O(N)), or</li>
<li>Keep list sorted; insertion O(N), deleteMin O(1)</li></ul>

<p>A binary search tree:</p>
<ul><li>This gives an O(log N) average for both operations.</li>
<li>But BST class supports a lot of operations that are not required</li></ul>

<p>An array: Binary Heap<p>
<ul><li>Does not require links and will support both operations in O(log N) even in worst-cases.</li></ul>

<h3>4.1.4 Binary Heaps - Definition</h3>
<p>The binary heap is the classic method used to implement priority queues which has following two properties</p>
<h3>Structure Property</h3>
<ul><li>A heap is a complete binary tree, represented as an array.</li>
<li>A complete binary tree is a tree that is completely filled, with the possible exception of the bottom level, which is filled from left to right.</li></ul>
<h3>Heap Order Property</h3>
<ul><li>In a heap, for every node X with parent P, value key in P is smaller than or equal to value in X.</li>
<li>Thus minimum element is always at the root.</li>
<li>findMin can be done in constant time i.e. O(1).</li></ul>

<h3>4.1.5 Complete Binary tree</h3>
<ul><li>A complete binary tree of height h has between 2<sup>h</sup> and   2<sup>h+1</sup> � 1 nodes</li>
<li>The height of a complete binary tree is [log N].</li>
<li>Since it is very much regular, it can be implemented as an array without any pointers such that:</li>
<li>For any element in array position i : </li>
<ul><li>left child is in position 2i, </li>
<li>right child is in the cell after the left child (2i + 1)</li>
<li>parent is in position [ i/2 ].</li></ul>
</ul>

<p>Complete Binary tree - Example</p>
<img src="hs2.png" style="width:300px;height:180px;margin-left:30px">

<h3>Heap Order Property- Min Heap</h3>
<p>Value key in Parent is smaller than or equal to value in child.</p>
<img src="hs3.png" style="width:300px;height:200px;margin-left:30px">

<h3>4.1.6 Priority Queue  - Min Heap Operations</h3>
<h3>Insertion</h3>
<p>To insert an element X into the heap:</p>
<li>We create a hole in the next available location.</li>
<li>If X can be placed there without violating the heap property, then we do so and are done.</li>
<li>Otherwise </li>
<ul>
<li>We bubble up the hole toward the root by sliding the element in the hole�s parent down.</li>
<li>We continue this until X can be placed in the hole.</li>
<li>This general strategy is known as a percolate up</li>
</ul>

<h3>Example</h3>
<img src="hs4.png" style="width:300px;height:180px;margin-left:30px">
</br></br>
<img src="hs5.png" style="width:300px;height:180px;margin-left:30px">

<h3>Deletion</h3>
<p>To perform DeleteMin in a heap:</p>
<li>Remove the minimum; so, a hole is created at the root.</li>
<li>The last element X must move somewhere in the heap.</li>
<li>If X can be placed in the hole then we are done.</li>
<li>Otherwise</li>
<ul>
<li>We slide the smaller of the hole�s children into the hole, thus pushing the hole one level down.</li>
<li>We repeat this until X can be placed in the hole.</li>
<li>This strategy is called as a percolate down.</li>
</ul>

<img src="hs6.png" style="width:300px;height:180px;margin-left:30px">
</br></br>
<img src="hs7.png" style="width:300px;height:180px;margin-left:30px">
</br></br>
<img src="hs8.png" style="width:300px;height:180px;margin-left:30px">


<h3>4.1.7 Priority Queue  - Min Heap Implementation</h3>

<h3>Heap structure</h3>
<img src="hs12.png" style="width:300px;height:180px;margin-left:30px">



<li>max_heap_size � maximum size of array</li>
<li>size � Current number of elements in array></li>

<h3>Creating a priority queue</h3>
<img src="hs13.png" style="width:300px;height:180px;margin-left:30px">
<img src="hs14.png" style="width:300px;height:180px;margin-left:30px">

<h3>Insertion</h3>
<img src="hs15.png" style="width:300px;height:250px;margin-left:30px">


<h3>Deletion</h3>
<img src="hs16.png" style="width:300px;height:200px;margin-left:30px">
<img src="hs17.png" style="width:300px;height:200px;margin-left:30px">






</body>